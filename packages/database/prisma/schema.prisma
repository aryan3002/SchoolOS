// SchoolOS Database Schema
// Multi-tenant school operating system with AI-first architecture
// 
// Key Design Principles:
// 1. Every table has districtId for tenant isolation (except District itself)
// 2. Soft delete support via deletedAt timestamp
// 3. Audit logging for all sensitive operations
// 4. Relationship-based access control for student data
// 5. Vector embeddings for RAG-based knowledge retrieval

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions", "fullTextSearch"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pgvector(map: "vector"), uuidOssp(map: "uuid-ossp"), pgcrypto, pg_trgm]
}

// ============================================================
// ENUMS
// ============================================================

enum UserRole {
  PARENT
  TEACHER
  STUDENT
  ADMIN
  STAFF
}

enum UserStatus {
  PENDING               // Awaiting email verification/account setup
  PENDING_VERIFICATION  // Awaiting verification
  ACTIVE                // Active account
  INACTIVE              // Inactive account  
  SUSPENDED             // Temporarily disabled
  ARCHIVED              // Soft deleted / graduated
}

enum RelationshipType {
  PARENT_OF       // Parent-child relationship
  GUARDIAN_OF     // Legal guardian
  TEACHER_OF      // Teacher-student (via section)
  COTEACHER_OF    // Co-teacher relationship
  COUNSELOR_OF    // Counselor-student
  ADMIN_OF        // Admin oversight
}

enum RelationshipStatus {
  PENDING   // Awaiting approval
  ACTIVE    // Currently active
  EXPIRED   // Ended (graduation, transfer)
  REVOKED   // Manually revoked
}

enum KnowledgeSourceType {
  PDF
  WEB_PAGE
  POLICY_DOCUMENT
  HANDBOOK
  ANNOUNCEMENT
  FAQ
  FORM
  CALENDAR
}

enum KnowledgeSourceStatus {
  DRAFT
  PENDING_REVIEW
  PUBLISHED
  ARCHIVED
  EXPIRED
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}

enum ConversationStatus {
  ACTIVE
  RESOLVED
  ESCALATED
  ARCHIVED
}

enum AuditAction {
  CREATE
  READ
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  LOGIN_FAILED
  PERMISSION_DENIED
  EXPORT
  BULK_OPERATION
}

enum TokenType {
  EMAIL_VERIFICATION
  PASSWORD_RESET
  MAGIC_LINK
  REFRESH_TOKEN
}

// ============================================================
// TENANT & IDENTITY MODELS
// ============================================================

/// District represents a school district (tenant boundary)
/// All data is isolated by district - this is the root of multi-tenancy
model District {
  id        String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  
  // Basic info
  name      String   @db.VarChar(255)
  slug      String   @unique @db.VarChar(100)  // URL-friendly identifier
  domain    String?  @unique @db.VarChar(255)  // Custom domain for SSO
  
  // Configuration
  timezone  String   @default("America/New_York") @db.VarChar(50)
  settings  Json     @default("{}")  // District-specific settings
  features  Json     @default("{}")  // Feature flags
  branding  Json     @default("{}")  // Logo, colors, etc.
  
  // Subscription / limits
  maxUsers  Int      @default(10000) @map("max_users")
  maxStorageGb Int   @default(100) @map("max_storage_gb")
  
  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")
  
  // Relations
  users              User[]
  relationships      UserRelationship[]
  knowledgeSources   KnowledgeSource[]
  conversations      Conversation[]
  auditLogs          AuditLog[]
  schools            School[]
  tokens             Token[]
  
  @@index([slug])
  @@index([domain])
  @@index([deletedAt])
  @@map("districts")
}

/// School represents an individual school within a district
model School {
  id          String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  districtId  String   @map("district_id") @db.Uuid
  
  name        String   @db.VarChar(255)
  code        String   @db.VarChar(50)  // School code (e.g., "EHS" for "Eastside High School")
  type        String   @db.VarChar(50)  // elementary, middle, high, etc.
  address     Json?    // Structured address
  phone       String?  @db.VarChar(20)
  principal   String?  @db.VarChar(255)
  
  settings    Json     @default("{}")
  
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  deletedAt   DateTime? @map("deleted_at")
  
  // Relations
  district    District @relation(fields: [districtId], references: [id], onDelete: Cascade)
  sections    Section[]
  users       User[]
  
  @@unique([districtId, code])
  @@index([districtId])
  @@index([deletedAt])
  @@map("schools")
}

/// Section represents a class section (e.g., "Math 101 - Period 3")
model Section {
  id          String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  schoolId    String   @map("school_id") @db.Uuid
  
  name        String   @db.VarChar(255)
  code        String   @db.VarChar(50)   // Section code from SIS
  subject     String?  @db.VarChar(100)
  gradeLevel  String?  @map("grade_level") @db.VarChar(20)
  period      String?  @db.VarChar(20)
  room        String?  @db.VarChar(50)
  
  // School year info
  schoolYear  String   @map("school_year") @db.VarChar(20)  // e.g., "2025-2026"
  semester    String?  @db.VarChar(20)  // fall, spring, full-year
  
  // External IDs for integration
  sisId       String?  @map("sis_id") @db.VarChar(100)  // PowerSchool/Skyward ID
  lmsId       String?  @map("lms_id") @db.VarChar(100)  // Canvas/Google Classroom ID
  
  settings    Json     @default("{}")
  
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  deletedAt   DateTime? @map("deleted_at")
  
  // Relations
  school              School @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  relationships       UserRelationship[] @relation("SectionRelationships")
  
  @@unique([schoolId, code, schoolYear])
  @@index([schoolId])
  @@index([sisId])
  @@index([lmsId])
  @@index([deletedAt])
  @@map("sections")
}

/// User represents any person in the system
model User {
  id          String     @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  districtId  String     @map("district_id") @db.Uuid
  
  // Identity
  email       String     @db.VarChar(255)
  phoneNumber String?    @map("phone_number") @db.VarChar(20)
  
  // Authentication
  passwordHash String?   @map("password_hash") @db.VarChar(255)
  emailVerified Boolean  @default(false) @map("email_verified")
  
  // Profile
  firstName   String     @map("first_name") @db.VarChar(100)
  lastName    String     @map("last_name") @db.VarChar(100)
  preferredName String?  @map("preferred_name") @db.VarChar(100)
  avatarUrl   String?    @map("avatar_url") @db.VarChar(500)
  
  // Role & Status
  role        UserRole
  status      UserStatus @default(PENDING)
  
  // School affiliation (optional, for students/teachers)
  schoolId    String?    @map("school_id") @db.Uuid
  
  // External IDs for integration
  sisId       String?    @map("sis_id") @db.VarChar(100)  // PowerSchool/Skyward student/staff ID
  
  // Metadata for extensibility
  metadata    Json       @default("{}")
  preferences Json       @default("{}")  // UI preferences, notification settings
  
  // Security
  lastLoginAt     DateTime? @map("last_login_at")
  failedLoginCount Int      @default(0) @map("failed_login_count")
  lockedUntil     DateTime? @map("locked_until")
  emailVerifiedAt DateTime? @map("email_verified_at")
  
  // Timestamps
  createdAt   DateTime   @default(now()) @map("created_at")
  updatedAt   DateTime   @updatedAt @map("updated_at")
  deletedAt   DateTime?  @map("deleted_at")
  
  // Relations
  district              District           @relation(fields: [districtId], references: [id], onDelete: Cascade)
  school                School?            @relation(fields: [schoolId], references: [id], onDelete: SetNull)
  relationshipsAsUser   UserRelationship[] @relation("UserRelationships")
  relationshipsAsTarget UserRelationship[] @relation("TargetRelationships")
  conversations         Conversation[]
  messages              Message[]
  auditLogs             AuditLog[]
  tokens                Token[]
  
  @@unique([districtId, email])
  @@index([districtId])
  @@index([email])
  @@index([role])
  @@index([status])
  @@index([schoolId])
  @@index([sisId])
  @@index([deletedAt])
  @@map("users")
}

/// UserRelationship defines relationships between users (parent-child, teacher-student)
/// This is critical for relationship-based access control
model UserRelationship {
  id              String             @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  districtId      String             @map("district_id") @db.Uuid
  
  // The user who HAS the relationship (parent, teacher)
  userId          String             @map("user_id") @db.Uuid
  
  // The user who IS the target (child, student)
  relatedUserId   String             @map("related_user_id") @db.Uuid
  
  // Relationship type
  relationshipType RelationshipType  @map("relationship_type")
  status          RelationshipStatus @default(PENDING)
  
  // For parent relationships: isPrimary indicates primary guardian
  isPrimary       Boolean?           @map("is_primary")  @default(false)
  
  // For teacher-student relationships, link to section
  sectionId       String?            @map("section_id") @db.Uuid
  
  // Metadata for additional context
  // For parents: isPrimary, canPickup, emergencyContact, custodyNotes
  // For teachers: role (lead, co-teacher, aide)
  metadata        Json               @default("{}")
  
  // Validity period
  startDate       DateTime           @default(now()) @map("start_date")
  endDate         DateTime?          @map("end_date")
  
  // Verification tracking (optional manual verification by admin)
  verifiedBy      String?            @map("verified_by") @db.Uuid
  verifiedAt      DateTime?          @map("verified_at")
  
  // Approval tracking
  approvedBy      String?            @map("approved_by") @db.Uuid
  approvedAt      DateTime?          @map("approved_at")
  
  // Timestamps
  createdAt       DateTime           @default(now()) @map("created_at")
  updatedAt       DateTime           @updatedAt @map("updated_at")
  deletedAt       DateTime?          @map("deleted_at")
  
  // Relations
  district        District           @relation(fields: [districtId], references: [id], onDelete: Cascade)
  user            User               @relation("UserRelationships", fields: [userId], references: [id], onDelete: Cascade)
  relatedUser     User               @relation("TargetRelationships", fields: [relatedUserId], references: [id], onDelete: Cascade)
  section         Section?           @relation("SectionRelationships", fields: [sectionId], references: [id], onDelete: SetNull)
  
  @@unique([userId, relatedUserId, relationshipType, sectionId])
  @@index([districtId])
  @@index([userId])
  @@index([relatedUserId])
  @@index([relationshipType])
  @@index([status])
  @@index([sectionId])
  @@index([deletedAt])
  @@map("user_relationships")
}

/// Token for various authentication flows
model Token {
  id          String    @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  districtId  String    @map("district_id") @db.Uuid
  userId      String    @map("user_id") @db.Uuid
  
  type        TokenType
  tokenHash   String    @unique @map("token_hash") @db.VarChar(255)
  expiresAt   DateTime  @map("expires_at")
  usedAt      DateTime? @map("used_at")
  
  // For refresh tokens, track device info
  deviceInfo  Json?     @map("device_info")
  ipAddress   String?   @map("ip_address") @db.VarChar(45)
  
  createdAt   DateTime  @default(now()) @map("created_at")
  
  // Relations
  district    District  @relation(fields: [districtId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([districtId])
  @@index([userId])
  @@index([type])
  @@index([expiresAt])
  @@map("tokens")
}

// ============================================================
// KNOWLEDGE MODELS (for RAG)
// ============================================================

/// KnowledgeSource represents a document, policy, or other knowledge artifact
model KnowledgeSource {
  id            String                @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  districtId    String                @map("district_id") @db.Uuid
  
  // Content identification
  title         String                @db.VarChar(500)
  description   String?               @db.Text
  sourceType    KnowledgeSourceType   @map("source_type")
  
  // Original content
  content       String?               @db.Text  // Extracted text content
  originalUrl   String?               @map("original_url") @db.VarChar(1000)
  fileUrl       String?               @map("file_url") @db.VarChar(1000)  // S3 URL if uploaded
  fileMimeType  String?               @map("file_mime_type") @db.VarChar(100)
  fileSize      Int?                  @map("file_size")  // In bytes
  
  // Versioning
  version       Int                   @default(1)
  parentId      String?               @map("parent_id") @db.Uuid  // Previous version
  
  // Status & visibility
  status        KnowledgeSourceStatus @default(DRAFT)
  isPublic      Boolean               @default(false) @map("is_public")  // Visible to all district users
  visibleToRoles UserRole[]           @default([]) @map("visible_to_roles")  // Role-based visibility
  
  // Approval workflow
  reviewedBy    String?               @map("reviewed_by") @db.Uuid  // User who reviewed
  reviewedAt    DateTime?             @map("reviewed_at")
  reviewNotes   String?               @map("review_notes") @db.Text
  approvedBy    String?               @map("approved_by") @db.Uuid  // User who approved/published
  approvedAt    DateTime?             @map("approved_at")
  
  // Validity
  publishedAt   DateTime?             @map("published_at")
  expiresAt     DateTime?             @map("expires_at")
  
  // Freshness tracking
  contentHash   String?               @map("content_hash") @db.VarChar(64)  // SHA-256 of content
  lastCheckedAt DateTime?             @map("last_checked_at")  // Last time source was checked for updates
  lastModifiedAt DateTime?            @map("last_modified_at")  // Last time content actually changed
  checkFrequencyDays Int?             @map("check_frequency_days") @default(30)  // How often to check for updates
  autoUpdateEnabled Boolean           @default(false) @map("auto_update_enabled")  // Auto-create new version on content change
  
  // Categorization
  category      String?               @db.VarChar(100)  // e.g., "transportation", "academics"
  tags          String[]              @default([])
  
  // Metadata
  metadata      Json                  @default("{}")  // Additional structured data
  
  // Processing status
  processedAt   DateTime?             @map("processed_at")  // When chunks were generated
  processingError String?             @map("processing_error") @db.Text
  
  // Timestamps
  createdAt     DateTime              @default(now()) @map("created_at")
  updatedAt     DateTime              @updatedAt @map("updated_at")
  deletedAt     DateTime?             @map("deleted_at")
  createdBy     String?               @map("created_by") @db.Uuid
  
  // Relations
  district      District              @relation(fields: [districtId], references: [id], onDelete: Cascade)
  chunks        KnowledgeChunk[]
  parent        KnowledgeSource?      @relation("KnowledgeVersions", fields: [parentId], references: [id], onDelete: SetNull)
  versions      KnowledgeSource[]     @relation("KnowledgeVersions")
  
  @@index([districtId])
  @@index([sourceType])
  @@index([status])
  @@index([category])
  @@index([tags])
  @@index([deletedAt])
  @@index([publishedAt])
  @@index([expiresAt])
  @@map("knowledge_sources")
}

/// KnowledgeChunk represents a chunk of a knowledge source for vector search
model KnowledgeChunk {
  id          String          @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  sourceId    String          @map("source_id") @db.Uuid
  
  // Content
  content     String          @db.Text
  
  // Vector embedding (1536 dimensions for OpenAI ada-002, 3072 for Claude)
  embedding   Unsupported("vector(1536)")?
  
  // Position within source
  chunkIndex  Int             @map("chunk_index")
  startOffset Int?            @map("start_offset")  // Character offset in original
  endOffset   Int?            @map("end_offset")
  
  // Metadata for retrieval
  metadata    Json            @default("{}")  // Section headers, page numbers, etc.
  
  // Timestamps
  createdAt   DateTime        @default(now()) @map("created_at")
  updatedAt   DateTime        @updatedAt @map("updated_at")
  
  // Relations
  source      KnowledgeSource @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  citations   MessageSource[]
  
  @@unique([sourceId, chunkIndex])
  @@index([sourceId])
  @@map("knowledge_chunks")
}

// ============================================================
// CONVERSATION MODELS
// ============================================================

/// Conversation represents a chat session
model Conversation {
  id          String             @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  districtId  String             @map("district_id") @db.Uuid
  userId      String             @map("user_id") @db.Uuid
  
  // For parents, which child is this conversation about?
  childId     String?            @map("child_id") @db.Uuid
  
  // Conversation state
  status      ConversationStatus @default(ACTIVE)
  
  // Conversation summary for context
  title       String?            @db.VarChar(255)  // Auto-generated from first message
  summary     String?            @db.Text  // AI-generated summary for long conversations
  
  // Metadata
  metadata    Json               @default("{}")  // Topic, category, sentiment, etc.
  
  // Timestamps
  createdAt   DateTime           @default(now()) @map("created_at")
  updatedAt   DateTime           @updatedAt @map("updated_at")
  closedAt    DateTime?          @map("closed_at")
  
  // Relations
  district    District           @relation(fields: [districtId], references: [id], onDelete: Cascade)
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages    Message[]
  
  @@index([districtId])
  @@index([userId])
  @@index([childId])
  @@index([status])
  @@index([createdAt])
  @@map("conversations")
}

/// Message represents a single message in a conversation
model Message {
  id              String        @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  conversationId  String        @map("conversation_id") @db.Uuid
  userId          String?       @map("user_id") @db.Uuid  // Null for assistant messages
  
  // Message content
  role            MessageRole
  content         String        @db.Text
  
  // AI metadata (for assistant messages)
  confidence      Float?        // 0-1 confidence score
  modelUsed       String?       @map("model_used") @db.VarChar(100)
  promptTokens    Int?          @map("prompt_tokens")
  completionTokens Int?         @map("completion_tokens")
  latencyMs       Int?          @map("latency_ms")
  
  // Tool calls (if any)
  toolCalls       Json?         @map("tool_calls")  // Array of tool call objects
  
  // Feedback
  rating          Int?          // 1-5 user rating
  feedback        String?       @db.Text  // User feedback text
  
  // General metadata for extensibility
  metadata        Json          @default("{}")  // Intent, citations, tools used, etc.
  
  // Timestamps
  createdAt       DateTime      @default(now()) @map("created_at")
  
  // Relations
  conversation    Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user            User?         @relation(fields: [userId], references: [id], onDelete: SetNull)
  sources         MessageSource[]
  
  @@index([conversationId])
  @@index([role])
  @@index([createdAt])
  @@map("messages")
}

/// MessageSource tracks which knowledge chunks were used to generate a message
/// This is critical for source-grounded responses
model MessageSource {
  id          String         @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  messageId   String         @map("message_id") @db.Uuid
  chunkId     String         @map("chunk_id") @db.Uuid
  
  // Relevance
  relevanceScore Float       @map("relevance_score")  // How relevant was this chunk
  usedInResponse Boolean     @default(true) @map("used_in_response")  // Was it actually used
  
  // Citation details
  citation    String?        @db.Text  // The actual quoted text
  
  createdAt   DateTime       @default(now()) @map("created_at")
  
  // Relations
  message     Message        @relation(fields: [messageId], references: [id], onDelete: Cascade)
  chunk       KnowledgeChunk @relation(fields: [chunkId], references: [id], onDelete: Cascade)
  
  @@unique([messageId, chunkId])
  @@index([messageId])
  @@index([chunkId])
  @@map("message_sources")
}

// ============================================================
// AUDIT MODELS
// ============================================================

/// AuditLog tracks all sensitive operations for compliance
model AuditLog {
  id          String      @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  districtId  String      @map("district_id") @db.Uuid
  userId      String?     @map("user_id") @db.Uuid  // Null for system actions
  
  // Action details
  action      AuditAction
  entityType  String      @map("entity_type") @db.VarChar(100)  // e.g., "User", "StudentRecord"
  entityId    String?     @map("entity_id") @db.VarChar(100)
  
  // What changed
  changes     Json?       // { before: {...}, after: {...} }
  
  // Request context
  ipAddress   String?     @map("ip_address") @db.VarChar(45)
  userAgent   String?     @map("user_agent") @db.VarChar(500)
  requestId   String?     @map("request_id") @db.VarChar(100)  // For tracing
  
  // Additional context
  metadata    Json        @default("{}")
  
  // Timestamp
  createdAt   DateTime    @default(now()) @map("created_at")
  
  // Relations
  district    District    @relation(fields: [districtId], references: [id], onDelete: Cascade)
  user        User?       @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@index([districtId])
  @@index([userId])
  @@index([action])
  @@index([entityType])
  @@index([entityId])
  @@index([createdAt])
  @@map("audit_logs")
}
