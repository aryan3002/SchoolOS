/**
 * Relationships Service
 *
 * Handles user relationship CRUD operations and queries.
 */

import {
  Injectable,
  Logger,
  NotFoundException,
  ConflictException,
  BadRequestException,
} from '@nestjs/common';
import {
  RelationshipType,
  RelationshipStatus,
  UserRole,
} from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';

import { PrismaService } from '../database/prisma.service';
import { RelationshipCacheService } from './relationship-cache.service';

export interface RelationshipRecord {
  id: string;
  userId: string;
  relatedUserId: string;
  relationshipType: RelationshipType;
  status: RelationshipStatus;
  isPrimary: boolean | null;
  metadata: Record<string, unknown>;
  verifiedAt: Date | null;
  verifiedBy: string | null;
  createdAt: Date;
  updatedAt: Date;
  user?: {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    role: UserRole;
  };
  relatedUser?: {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    role: UserRole;
  };
}

export interface CreateRelationshipInput {
  userId: string;
  relatedUserId: string;
  relationshipType: RelationshipType;
  isPrimary?: boolean;
  metadata?: Record<string, unknown>;
  districtId: string;
}

export interface UpdateRelationshipInput {
  status?: RelationshipStatus;
  isPrimary?: boolean;
  metadata?: Record<string, unknown>;
}

export interface RelationshipQueryOptions {
  districtId: string;
  userId?: string;
  relationshipType?: RelationshipType;
  status?: RelationshipStatus;
  page?: number;
  pageSize?: number;
}

// Valid relationship type mappings by role
const VALID_RELATIONSHIPS: Record<RelationshipType, { primary: UserRole[]; related: UserRole[] }> = {
  [RelationshipType.PARENT_OF]: {
    primary: [UserRole.PARENT],
    related: [UserRole.STUDENT],
  },
  [RelationshipType.GUARDIAN_OF]: {
    primary: [UserRole.PARENT],
    related: [UserRole.STUDENT],
  },
  [RelationshipType.TEACHER_OF]: {
    primary: [UserRole.TEACHER],
    related: [UserRole.STUDENT],
  },
  [RelationshipType.COUNSELOR_OF]: {
    primary: [UserRole.ADMIN, UserRole.TEACHER],
    related: [UserRole.STUDENT],
  },
  [RelationshipType.COTEACHER_OF]: {
    primary: [UserRole.TEACHER],
    related: [UserRole.TEACHER],
  },
  [RelationshipType.ADMIN_OF]: {
    primary: [UserRole.ADMIN],
    related: [UserRole.STUDENT, UserRole.TEACHER, UserRole.PARENT],
  },
};

@Injectable()
export class RelationshipsService {
  private readonly logger = new Logger(RelationshipsService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly cacheService: RelationshipCacheService,
  ) {}

  /**
   * Find relationship by ID
   */
  async findById(id: string, districtId: string): Promise<RelationshipRecord | null> {
    const relationship = await this.prisma.userRelationship.findFirst({
      where: {
        id,
        user: { districtId },
      },
      include: {
        user: {
          select: { id: true, firstName: true, lastName: true, email: true, role: true },
        },
        relatedUser: {
          select: { id: true, firstName: true, lastName: true, email: true, role: true },
        },
      },
    });

    return relationship as RelationshipRecord | null;
  }

  /**
   * Get relationships for a user
   */
  async findForUser(
    userId: string,
    districtId: string,
    type?: RelationshipType,
  ): Promise<RelationshipRecord[]> {
    // Check cache first
    const cacheKey = `user:${userId}:${type ?? 'all'}`;
    const cached = await this.cacheService.get<RelationshipRecord[]>(cacheKey);

    if (cached) {
      return cached;
    }

    const where: Parameters<typeof this.prisma.userRelationship.findMany>[0]['where'] = {
      OR: [{ primaryUserId: userId }, { relatedUserId: userId }],
      user: { districtId },
      status: RelationshipStatus.ACTIVE,
    };

    if (type) {
      where.relationshipType = type;
    }

    const relationships = await this.prisma.userRelationship.findMany({
      where,
      include: {
        user: {
          select: { id: true, firstName: true, lastName: true, email: true, role: true },
        },
        relatedUser: {
          select: { id: true, firstName: true, lastName: true, email: true, role: true },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    // Cache the result
    await this.cacheService.set(cacheKey, relationships, 5 * 60); // 5 minutes

    return relationships as RelationshipRecord[];
  }

  /**
   * Get all relationships with filtering and pagination
   */
  async findMany(options: RelationshipQueryOptions): Promise<{
    relationships: RelationshipRecord[];
    total: number;
    page: number;
    pageSize: number;
    totalPages: number;
  }> {
    const {
      districtId,
      userId,
      relationshipType,
      status,
      page = 1,
      pageSize = 20,
    } = options;

    const where: Parameters<typeof this.prisma.userRelationship.findMany>[0]['where'] = {
      user: { districtId },
    };

    if (userId) {
      where.OR = [{ primaryUserId: userId }, { relatedUserId: userId }];
    }

    if (relationshipType) {
      where.relationshipType = relationshipType;
    }

    if (status) {
      where.status = status;
    }

    const [relationships, total] = await Promise.all([
      this.prisma.userRelationship.findMany({
        where,
        include: {
          user: {
            select: { id: true, firstName: true, lastName: true, email: true, role: true },
          },
          relatedUser: {
            select: { id: true, firstName: true, lastName: true, email: true, role: true },
          },
        },
        skip: (page - 1) * pageSize,
        take: pageSize,
        orderBy: { createdAt: 'desc' },
      }),
      this.prisma.userRelationship.count({ where }),
    ]);

    return {
      relationships: relationships as RelationshipRecord[],
      total,
      page,
      pageSize,
      totalPages: Math.ceil(total / pageSize),
    };
  }

  /**
   * Create a new relationship
   */
  async create(input: CreateRelationshipInput): Promise<RelationshipRecord> {
    // Validate users exist and are in the same district
    const [primaryUser, relatedUser] = await Promise.all([
      this.prisma.user.findFirst({
        where: { id: input.primaryUserId, districtId: input.districtId },
      }),
      this.prisma.user.findFirst({
        where: { id: input.relatedUserId, districtId: input.districtId },
      }),
    ]);

    if (!primaryUser) {
      throw new BadRequestException({
        code: 'INVALID_PRIMARY_USER',
        message: 'Primary user not found in district',
      });
    }

    if (!relatedUser) {
      throw new BadRequestException({
        code: 'INVALID_RELATED_USER',
        message: 'Related user not found in district',
      });
    }

    // Validate relationship type based on roles
    this.validateRelationshipRoles(
      input.relationshipType,
      primaryUser.role,
      relatedUser.role,
    );

    // Check for existing relationship
    const existing = await this.prisma.userRelationship.findFirst({
      where: {
        userId: input.userId,
        relatedUserId: input.relatedUserId,
        relationshipType: input.relationshipType,
        status: { not: RelationshipStatus.REVOKED },
      },
    });

    if (existing) {
      throw new ConflictException({
        code: 'RELATIONSHIP_EXISTS',
        message: 'This relationship already exists',
      });
    }

    // Create relationship
    const relationship = await this.prisma.userRelationship.create({
      data: {
        id: uuidv4(),
        userId: input.userId,
        relatedUserId: input.relatedUserId,
        relationshipType: input.relationshipType,
        status: RelationshipStatus.PENDING,
        isPrimary: input.isPrimary ?? false,
        metadata: input.metadata ?? {},
      },
      include: {
        user: {
          select: { id: true, firstName: true, lastName: true, email: true, role: true },
        },
        relatedUser: {
          select: { id: true, firstName: true, lastName: true, email: true, role: true },
        },
      },
    });

    // Invalidate cache
    await this.invalidateCacheForUsers([input.primaryUserId, input.relatedUserId]);

    this.logger.log(
      `Relationship created: ${input.relationshipType} between ${primaryUser.email} and ${relatedUser.email}`,
    );

    return relationship as RelationshipRecord;
  }

  /**
   * Update relationship
   */
  async update(
    id: string,
    input: UpdateRelationshipInput,
    districtId: string,
    verifiedBy?: string,
  ): Promise<RelationshipRecord> {
    const existing = await this.findById(id, districtId);

    if (!existing) {
      throw new NotFoundException({
        code: 'RELATIONSHIP_NOT_FOUND',
        message: 'Relationship not found',
      });
    }

    const data: Parameters<typeof this.prisma.userRelationship.update>[0]['data'] = {};

    if (input.status !== undefined) {
      data.status = input.status;

      // Set verification info if activating
      if (input.status === RelationshipStatus.ACTIVE && verifiedBy) {
        data.verifiedAt = new Date();
        data.verifiedBy = verifiedBy;
      }
    }

    if (input.isPrimary !== undefined) {
      data.isPrimary = input.isPrimary;
    }

    if (input.metadata !== undefined) {
      data.metadata = input.metadata;
    }

    const relationship = await this.prisma.userRelationship.update({
      where: { id },
      data,
      include: {
        user: {
          select: { id: true, firstName: true, lastName: true, email: true, role: true },
        },
        relatedUser: {
          select: { id: true, firstName: true, lastName: true, email: true, role: true },
        },
      },
    });

    // Invalidate cache
    await this.invalidateCacheForUsers([
      existing.primaryUserId,
      existing.relatedUserId,
    ]);

    this.logger.log(`Relationship updated: ${id}`);

    return relationship as RelationshipRecord;
  }

  /**
   * Verify/activate a relationship
   */
  async verify(
    id: string,
    districtId: string,
    verifiedBy: string,
  ): Promise<RelationshipRecord> {
    return this.update(
      id,
      { status: RelationshipStatus.ACTIVE },
      districtId,
      verifiedBy,
    );
  }

  /**
   * Revoke a relationship
   */
  async revoke(id: string, districtId: string): Promise<RelationshipRecord> {
    return this.update(id, { status: RelationshipStatus.REVOKED }, districtId);
  }

  /**
   * Delete relationship (hard delete)
   */
  async delete(id: string, districtId: string): Promise<void> {
    const existing = await this.findById(id, districtId);

    if (!existing) {
      throw new NotFoundException({
        code: 'RELATIONSHIP_NOT_FOUND',
        message: 'Relationship not found',
      });
    }

    await this.prisma.userRelationship.delete({
      where: { id },
    });

    // Invalidate cache
    await this.invalidateCacheForUsers([
      existing.primaryUserId,
      existing.relatedUserId,
    ]);

    this.logger.log(`Relationship deleted: ${id}`);
  }

  /**
   * Check if relationship exists between two users
   */
  async hasRelationship(
    userId1: string,
    userId2: string,
    types?: RelationshipType[],
  ): Promise<boolean> {
    const where: Parameters<typeof this.prisma.userRelationship.findFirst>[0]['where'] = {
      status: RelationshipStatus.ACTIVE,
      OR: [
        { primaryUserId: userId1, relatedUserId: userId2 },
        { primaryUserId: userId2, relatedUserId: userId1 },
      ],
    };

    if (types && types.length > 0) {
      where.relationshipType = { in: types };
    }

    const relationship = await this.prisma.userRelationship.findFirst({ where });

    return relationship !== null;
  }

  /**
   * Get all related user IDs for a user
   */
  async getRelatedUserIds(
    userId: string,
    types?: RelationshipType[],
  ): Promise<string[]> {
    const where: Parameters<typeof this.prisma.userRelationship.findMany>[0]['where'] = {
      status: RelationshipStatus.ACTIVE,
      OR: [{ primaryUserId: userId }, { relatedUserId: userId }],
    };

    if (types && types.length > 0) {
      where.relationshipType = { in: types };
    }

    const relationships = await this.prisma.userRelationship.findMany({
      where,
      select: {
        primaryUserId: true,
        relatedUserId: true,
      },
    });

    const userIds = new Set<string>();

    relationships.forEach((rel) => {
      if (rel.primaryUserId !== userId) {
        userIds.add(rel.primaryUserId);
      }
      if (rel.relatedUserId !== userId) {
        userIds.add(rel.relatedUserId);
      }
    });

    return Array.from(userIds);
  }

  /**
   * Bulk create relationships (for SIS sync)
   */
  async bulkCreate(
    relationships: CreateRelationshipInput[],
  ): Promise<{ created: number; skipped: number; errors: string[] }> {
    let created = 0;
    let skipped = 0;
    const errors: string[] = [];

    for (const input of relationships) {
      try {
        await this.create(input);
        created++;
      } catch (error) {
        if (error instanceof ConflictException) {
          skipped++;
        } else {
          errors.push(
            `Failed to create relationship ${input.primaryUserId} -> ${input.relatedUserId}: ${(error as Error).message}`,
          );
        }
      }
    }

    this.logger.log(
      `Bulk create completed: ${created} created, ${skipped} skipped, ${errors.length} errors`,
    );

    return { created, skipped, errors };
  }

  /**
   * Validate relationship type based on user roles
   */
  private validateRelationshipRoles(
    type: RelationshipType,
    primaryRole: UserRole,
    relatedRole: UserRole,
  ): void {
    const validRoles = VALID_RELATIONSHIPS[type];

    if (!validRoles) {
      throw new BadRequestException({
        code: 'INVALID_RELATIONSHIP_TYPE',
        message: 'Invalid relationship type',
      });
    }

    if (!validRoles.primary.includes(primaryRole)) {
      throw new BadRequestException({
        code: 'INVALID_PRIMARY_ROLE',
        message: `User with role ${primaryRole} cannot be the primary user in a ${type} relationship`,
      });
    }

    if (!validRoles.related.includes(relatedRole)) {
      throw new BadRequestException({
        code: 'INVALID_RELATED_ROLE',
        message: `User with role ${relatedRole} cannot be the related user in a ${type} relationship`,
      });
    }
  }

  /**
   * Invalidate cache for users
   */
  private async invalidateCacheForUsers(userIds: string[]): Promise<void> {
    for (const userId of userIds) {
      await this.cacheService.deletePattern(`user:${userId}:*`);
    }
  }
}
