/**
 * Authentication Service
 *
 * Handles user authentication, registration, and session management.
 */

import {
  Injectable,
  UnauthorizedException,
  ConflictException,
  BadRequestException,
  Logger,
  NotFoundException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { UserRole, UserStatus, TokenType, AuditAction } from '@prisma/client';
import * as bcrypt from 'bcrypt';
import { v4 as uuidv4 } from 'uuid';
import { createHash } from 'crypto';

import { PrismaService } from '../database/prisma.service';
import { TokenService } from './token.service';
import {
  LoginDto,
  RegisterDto,
  ForgotPasswordDto,
  ResetPasswordDto,
  ChangePasswordDto,
} from './dto';

export interface AuthenticatedUser {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: UserRole;
  status: UserStatus;
  districtId: string;
  schoolId: string | null;
  emailVerified: boolean;
  lastLoginAt: Date | null;
}

export interface TokenPair {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
  tokenType: 'Bearer';
}

export interface AuthResponse {
  user: AuthenticatedUser;
  tokens: TokenPair;
}

// Constants
const MAX_LOGIN_ATTEMPTS = 5;
const LOCKOUT_DURATION_MINUTES = 15;
const PASSWORD_RESET_EXPIRY_HOURS = 1;
const EMAIL_VERIFY_EXPIRY_HOURS = 24;
const SALT_ROUNDS = 12;

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly tokenService: TokenService,
    private readonly configService: ConfigService,
  ) {}

  /**
   * Register a new user
   */
  async register(dto: RegisterDto): Promise<AuthResponse> {
    // Check if email already exists in this district
    const existingUser = await this.prisma.user.findUnique({
      where: { 
        districtId_email: {
          districtId: dto.districtId,
          email: dto.email
        }
      },
    });

    if (existingUser) {
      throw new ConflictException({
        code: 'EMAIL_EXISTS',
        message: 'A user with this email already exists',
      });
    }

    // Verify district exists
    const district = await this.prisma.district.findUnique({
      where: { id: dto.districtId },
    });

    if (!district) {
      throw new BadRequestException({
        code: 'INVALID_DISTRICT',
        message: 'Invalid district ID',
      });
    }

    // Verify school if provided
    if (dto.schoolId) {
      const school = await this.prisma.school.findFirst({
        where: {
          id: dto.schoolId,
          districtId: dto.districtId,
        },
      });

      if (!school) {
        throw new BadRequestException({
          code: 'INVALID_SCHOOL',
          message: 'Invalid school ID for this district',
        });
      }
    }

    // Hash password
    const passwordHash = await bcrypt.hash(dto.password, SALT_ROUNDS);

    // Create user
    const user = await this.prisma.user.create({
      data: {
        id: uuidv4(),
        email: dto.email,
        passwordHash,
        firstName: dto.firstName,
        lastName: dto.lastName,
        role: dto.role,
        status: UserStatus.PENDING,
        districtId: dto.districtId,
        schoolId: dto.schoolId ?? null,
        emailVerified: false,
        preferences: {},
      },
    });

    // Generate email verification token
    await this.tokenService.createToken(
      user.id,
      user.districtId,
      TokenType.EMAIL_VERIFICATION,
      EMAIL_VERIFY_EXPIRY_HOURS * 60,
    );

    // TODO: Send verification email

    // Generate tokens
    const tokens = await this.tokenService.generateTokenPair(user);

    // Log registration
    await this.logAuditEvent(user.id, user.districtId, AuditAction.CREATE, {
      email: user.email,
      role: user.role,
    });

    this.logger.log(`User registered: ${user.email}`);

    return {
      user: this.sanitizeUser(user),
      tokens,
    };
  }

  /**
   * Authenticate user with email and password
   */
  async login(dto: LoginDto): Promise<AuthResponse> {
    const user = await this.prisma.user.findFirst({
      where: { email: dto.email },
    });

    if (!user) {
      throw new UnauthorizedException({
        code: 'INVALID_CREDENTIALS',
        message: 'Invalid email or password',
      });
    }

    // Check if account is locked
    if (user.lockedUntil && user.lockedUntil > new Date()) {
      const remainingMinutes = Math.ceil(
        (user.lockedUntil.getTime() - Date.now()) / 60000,
      );
      throw new UnauthorizedException({
        code: AuditAction.UPDATE,
        message: `Account is locked. Try again in ${remainingMinutes} minutes`,
      });
    }

    // Check if account is active
    if (user.status === UserStatus.SUSPENDED) {
      throw new UnauthorizedException({
        code: 'ACCOUNT_SUSPENDED',
        message: 'Your account has been suspended. Please contact support.',
      });
    }

    if (user.status === UserStatus.INACTIVE) {
      throw new UnauthorizedException({
        code: 'ACCOUNT_INACTIVE',
        message: 'Your account is inactive. Please contact your administrator.',
      });
    }

    // Verify password
    if (!user.passwordHash) {
      throw new UnauthorizedException({
        code: 'INVALID_CREDENTIALS',
        message: 'Invalid email or password',
      });
    }
    const isPasswordValid = await bcrypt.compare(dto.password, user.passwordHash);

    if (!isPasswordValid) {
      // Increment failed attempts
      const failedAttempts = (user.failedLoginCount ?? 0) + 1;
      const lockAccount = failedAttempts >= MAX_LOGIN_ATTEMPTS;

      await this.prisma.user.update({
        where: { id: user.id },
        data: {
          failedLoginCount: failedAttempts,
          lockedUntil: lockAccount
            ? new Date(Date.now() + LOCKOUT_DURATION_MINUTES * 60 * 1000)
            : null,
        },
      });

      if (lockAccount) {
        await this.logAuditEvent(user.id, user.districtId, AuditAction.UPDATE, {
          reason: 'Too many failed login attempts',
        });

        throw new UnauthorizedException({
          code: AuditAction.UPDATE,
          message: `Account locked due to too many failed attempts. Try again in ${LOCKOUT_DURATION_MINUTES} minutes`,
        });
      }

      throw new UnauthorizedException({
        code: 'INVALID_CREDENTIALS',
        message: 'Invalid email or password',
      });
    }

    // Reset failed attempts and update last login
    await this.prisma.user.update({
      where: { id: user.id },
      data: {
        failedLoginCount: 0,
        lockedUntil: null,
        lastLoginAt: new Date(),
      },
    });

    // Generate tokens
    const expiresIn = dto.rememberMe ? 7 * 24 * 60 : undefined;
    const tokens = await this.tokenService.generateTokenPair(user, expiresIn);

    // Log login
    await this.logAuditEvent(user.id, user.districtId, AuditAction.LOGIN, {
      email: user.email,
    });

    this.logger.log(`User logged in: ${user.email}`);

    return {
      user: this.sanitizeUser(user),
      tokens,
    };
  }

  /**
   * Refresh access token using refresh token
   */
  async refreshTokens(refreshToken: string): Promise<TokenPair> {
    const payload = await this.tokenService.verifyRefreshToken(refreshToken);

    if (!payload) {
      throw new UnauthorizedException({
        code: 'INVALID_TOKEN',
        message: 'Invalid or expired refresh token',
      });
    }

    // Verify token exists in database and is not revoked
    const storedToken = await this.prisma.token.findFirst({
      where: {
        userId: payload.sub,
        type: TokenType.REFRESH_TOKEN,
        usedAt: null,
        expiresAt: { gt: new Date() },
      },
    });

    if (!storedToken) {
      throw new UnauthorizedException({
        code: 'TOKEN_REVOKED',
        message: 'Refresh token has been revoked',
      });
    }

    // Get user
    const user = await this.prisma.user.findUnique({
      where: { id: payload.sub },
    });

    if (!user || user.status !== UserStatus.ACTIVE) {
      throw new UnauthorizedException({
        code: 'USER_INACTIVE',
        message: 'User account is not active',
      });
    }

    // Revoke old refresh token (rotation)
    await this.prisma.token.update({
      where: { id: storedToken.id },
      data: { usedAt: new Date() },
    });

    // Generate new token pair
    return this.tokenService.generateTokenPair(user);
  }

  /**
   * Logout user (revoke tokens)
   */
  async logout(userId: string, refreshToken?: string, allDevices = false): Promise<void> {
    if (allDevices) {
      // Revoke all refresh tokens
      await this.prisma.token.updateMany({
        where: {
          userId,
          type: TokenType.REFRESH_TOKEN,
          usedAt: null,
        },
        data: { usedAt: new Date() },
      });

      this.logger.log(`User logged out from all devices: ${userId}`);
    } else if (refreshToken) {
      // Revoke specific refresh token
      const payload = await this.tokenService.verifyRefreshToken(refreshToken);

      if (payload) {
        await this.prisma.token.updateMany({
          where: {
            userId: payload.sub,
            type: TokenType.REFRESH_TOKEN,
            usedAt: null,
          },
          data: { usedAt: new Date() },
        });
      }
    }

    const user = await this.prisma.user.findUnique({ where: { id: userId } });
    if (user) {
      await this.logAuditEvent(userId, user.districtId, AuditAction.LOGOUT, {
        allDevices,
      });
    }
  }

  /**
   * Request password reset
   */
  async forgotPassword(dto: ForgotPasswordDto): Promise<void> {
    const user = await this.prisma.user.findFirst({
      where: { email: dto.email },
    });

    // Always return success to prevent email enumeration
    if (!user) {
      this.logger.debug(`Password reset requested for non-existent email: ${dto.email}`);
      return;
    }

    // Create password reset token
    const token = await this.tokenService.createToken(
      user.id,
      user.districtId,
      TokenType.PASSWORD_RESET,
      PASSWORD_RESET_EXPIRY_HOURS * 60,
    );

    // TODO: Send password reset email with token.token

    await this.logAuditEvent(user.id, user.districtId, AuditAction.UPDATE, {
      email: user.email,
    });

    this.logger.log(`Password reset requested for: ${user.email}`);
  }

  /**
   * Reset password with token
   */
  async resetPassword(dto: ResetPasswordDto): Promise<void> {
    // Find valid token
    const token = await this.prisma.token.findFirst({
      where: {
        tokenHash: this.hashToken(dto.token),
        type: TokenType.PASSWORD_RESET,
        usedAt: null,
        expiresAt: { gt: new Date() },
      },
      include: { user: true },
    });

    if (!token) {
      throw new BadRequestException({
        code: 'INVALID_TOKEN',
        message: 'Invalid or expired reset token',
      });
    }

    // Hash new password
    const passwordHash = await bcrypt.hash(dto.newPassword, SALT_ROUNDS);

    // Update password and revoke token
    await this.prisma.$transaction([
      this.prisma.user.update({
        where: { id: token.userId },
        data: {
          passwordHash,
          failedLoginCount: 0,
          lockedUntil: null,
        },
      }),
      this.prisma.token.update({
        where: { id: token.id },
        data: { usedAt: new Date() },
      }),
      // Revoke all refresh tokens (force re-login)
      this.prisma.token.updateMany({
        where: {
          userId: token.userId,
          type: TokenType.REFRESH_TOKEN,
          usedAt: null,
        },
        data: { usedAt: new Date() },
      }),
    ]);

    await this.logAuditEvent(token.userId, token.user.districtId, AuditAction.UPDATE, {
      email: token.user.email,
    });

    this.logger.log(`Password reset completed for: ${token.user.email}`);
  }

  /**
   * Change password (authenticated user)
   */
  async changePassword(userId: string, dto: ChangePasswordDto): Promise<void> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
    });

    if (!user) {
      throw new NotFoundException({
        code: 'USER_NOT_FOUND',
        message: 'User not found',
      });
    }

    // Verify current password
    if (!user.passwordHash) {
      throw new BadRequestException({
        code: 'NO_PASSWORD_SET',
        message: 'No password set for this account',
      });
    }
    const isPasswordValid = await bcrypt.compare(dto.currentPassword, user.passwordHash);

    if (!isPasswordValid) {
      throw new BadRequestException({
        code: 'INVALID_PASSWORD',
        message: 'Current password is incorrect',
      });
    }

    // Hash new password
    const passwordHash = await bcrypt.hash(dto.newPassword, SALT_ROUNDS);

    // Update password
    await this.prisma.user.update({
      where: { id: userId },
      data: { passwordHash },
    });

    await this.logAuditEvent(userId, user.districtId, 'PASSWORD_CHANGED', {
      email: user.email,
    });

    this.logger.log(`Password changed for: ${user.email}`);
  }

  /**
   * Verify email address
   */
  async verifyEmail(tokenString: string): Promise<void> {
    const token = await this.prisma.token.findFirst({
      where: {
        tokenHash: this.hashToken(tokenString),
        type: TokenType.EMAIL_VERIFICATION,
        usedAt: null,
        expiresAt: { gt: new Date() },
      },
      include: { user: true },
    });

    if (!token) {
      throw new BadRequestException({
        code: 'INVALID_TOKEN',
        message: 'Invalid or expired verification token',
      });
    }

    await this.prisma.$transaction([
      this.prisma.user.update({
        where: { id: token.userId },
        data: {
          emailVerifiedAt: new Date(),
          status:
            token.user.status === UserStatus.PENDING
              ? UserStatus.ACTIVE
              : token.user.status,
        },
      }),
      this.prisma.token.update({
        where: { id: token.id },
        data: { usedAt: new Date() },
      }),
    ]);

    await this.logAuditEvent(token.userId, token.user.districtId, 'EMAIL_VERIFIED', {
      email: token.user.email,
    });

    this.logger.log(`Email verified for: ${token.user.email}`);
  }

  /**
   * Get user by ID
   */
  async getUserById(userId: string): Promise<AuthenticatedUser | null> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
    });

    return user ? this.sanitizeUser(user) : null;
  }

  /**
   * Validate user for JWT strategy
   */
  async validateUser(payload: { sub: string }): Promise<AuthenticatedUser | null> {
    const user = await this.prisma.user.findUnique({
      where: { id: payload.sub },
    });

    if (!user || user.status !== UserStatus.ACTIVE) {
      return null;
    }

    return this.sanitizeUser(user);
  }

  /**
   * Remove sensitive fields from user object
   */
  private sanitizeUser(user: {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    role: UserRole;
    status: UserStatus;
    districtId: string;
    schoolId: string | null;
    emailVerifiedAt: Date | null;
    lastLoginAt: Date | null;
  }): AuthenticatedUser {
    return {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      status: user.status,
      districtId: user.districtId,
      schoolId: user.schoolId,
      emailVerified: user.emailVerifiedAt !== null,
      lastLoginAt: user.lastLoginAt,
    };
  }

  /**
   * Hash token for database storage
   */
  private hashToken(token: string): string {
    return createHash('sha256').update(token).digest('hex');
  }

  /**
   * Log audit event
   */
  private async logAuditEvent(
    userId: string,
    districtId: string,
    action: AuditAction,
    details?: Record<string, unknown>,
  ): Promise<void> {
    await this.prisma.auditLog.create({
      data: {
        id: uuidv4(),
        userId,
        districtId,
        action,
        entityType: 'User',
        entityId: userId,
        newValues: details ?? {},
      },
    });
  }
}
